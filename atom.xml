<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>居仙阁</title>
  <subtitle>有分享的地方就有成长的印记（本渣渣处于入门阶段，错误之处还望不吝指教）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-22T00:47:28.633Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xianhuojun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Studio内存泄露</title>
    <link href="http://yoursite.com/2016/08/19/Android%20Studio%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2016/08/19/Android Studio内存泄露/</id>
    <published>2016-08-19T08:52:50.000Z</published>
    <updated>2016-08-22T00:47:28.633Z</updated>
    
    <content type="html"><![CDATA[<p>　　内存泄露指的是在gc进行回收时，无法回收本应该回收的对象，造成该对象重复出现，占用内存，严重影响app性能。</p>
<p>　　最常见的内存泄露情况是handler作为匿名内部类直接使用，而不是使用静态内部类。这种情况，匿名内部类Handler会保持对外部类的一个引用（假设是Activity），那么Activity在本应该被回收的时候会因为保留有Handler引用，且Handler中的msg或者runnable还没运行完，那就造成Activity无法被回收了，产生泄露问题。解决的办法就是使用静态内部类，并且该静态内部类的引用在可能的情况下使用弱引用。如果非要使用Context参数，那尽量多用ApplicationContext吧，因为ApplicationContext属于单例，不用担心gc问题。</p>
<p>　　记录一下我使用as分析内存泄露的过程：左下角点击Android Monitor，现在上方选好要调试的Android设备和应用程序。然后，查看Memory的动态状体图，点击Initiate GC按钮，产生一次gc回收。再点击Dump Java Heap 导出目前的java堆使用情况。如图</p>
<p>　　<img src="https://github.com/wengxianhuo/wengxianhuo.github.io/blob/hexo/pictures/first.png?raw=true" alt="first"></p>
<p>　　<img src="https://github.com/wengxianhuo/wengxianhuo.github.io/blob/hexo/pictures/second.png?raw=true" alt="second"></p>
<p>　　然后看重复的变量，再看看变量的引用树，是什么原因让ｇｃ无法回收变量。</p>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　内存泄露指的是在gc进行回收时，无法回收本应该回收的对象，造成该对象重复出现，占用内存，严重影响app性能。&lt;/p&gt;
&lt;p&gt;　　最常见的内存泄露情况是handler作为匿名内部类直接使用，而不是使用静态内部类。这种情况，匿名内部类Handler会保持对外部类的一个引用（
    
    </summary>
    
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>jsp中css,js文件引用路径小结</title>
    <link href="http://yoursite.com/2016/07/29/jsp%E4%B8%ADcss-js%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/29/jsp中css-js文件引用路径小结/</id>
    <published>2016-07-29T08:02:39.000Z</published>
    <updated>2016-07-29T09:05:57.026Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天下午花了不少时间找这方面的资料，自己总结一下。先讲自己已经理清头绪的：相对路径是指，相对当前的jsp页面来说的，也就是说假想当前目录就为此时的jsp页面，要走怎样的路径才可以到达目标js或者css。如果jsp文件与目标js或css在同一级目录，如图：</p>
<p><img src="https://raw.githubusercontent.com/wengxianhuo/pictures/master/same_dir.png" alt="同一目录"></p>
<pre><code>大家都知道，assets是存放js，css资源的文件即assets/js和assets/css，为了图片比较简洁，我就不展开assets目录了。
</code></pre><p>　　此时我们的相对路径应该这么写：assets/js/js文件 或者 assets/css/css文件。原因就是上面说的，对于相对路径，我们假想从当前jsp开始寻找目标资源，在同一级目录，是可以直接反问的，没什么弯路。</p>
<p>但是，还有另一种情况，即：</p>
<p><img src="https://raw.githubusercontent.com/wengxianhuo/pictures/master/other_dir.png" alt="同一目录"></p>
<p>　　在这种情况下我们当然是没办法像上面一样直接就寻得资源，如图可知道当前jsp在低一级的目录，这时候我们要先找到跑到assets目录才行啊，所以出现了..这样的格式，使用..可以让我们回到上一级目录，即assets的所在目录，都找到assets目录了，自然也可以直接寻得资源，写法是：../assets/js/js文件或../assets/css/css文件<br>    ..有一个特别之处，他会自动往上一级寻找，如果上一级没找到，会寻找上上一级，直到根目录都没有找到assets目录就直接not found了</p>
<p>　　现在我们推荐使用绝对路径就是/project/资源路径的形式，用这种方式出现的错误会比较少吧，感觉上。。。当然了，这里也有特别需要注意的一点就是，你在tomcat中的server配置中的context的path属性设置为什么，那对应的project就是什么。比如<code>&lt;Context path=&quot;/amazeUI&quot; docBase=&quot;AmazeUI&quot; reloadable=&quot;false&quot; /&gt;</code>那我设置的绝对路径就应该是/amazeUI/assert/js/js文件。</p>
<p>　　如有不正之处，请多多包涵，多多指教。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天下午花了不少时间找这方面的资料，自己总结一下。先讲自己已经理清头绪的：相对路径是指，相对当前的jsp页面来说的，也就是说假想当前目录就为此时的jsp页面，要走怎样的路径才可以到达目标js或者css。如果jsp文件与目标js或css在同一级目录，如图：&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="js，css引用路径" scheme="http://yoursite.com/tags/js%EF%BC%8Ccss%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈android回调</title>
    <link href="http://yoursite.com/2016/07/28/%E8%B0%88%E8%B0%88%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%99%E5%9B%9E%E4%BA%8B/"/>
    <id>http://yoursite.com/2016/07/28/谈谈回调函数这回事/</id>
    <published>2016-07-28T13:07:50.000Z</published>
    <updated>2016-10-26T03:05:13.997Z</updated>
    
    <content type="html"><![CDATA[<p>在android开发中，回调接口出现的次数可谓不少，回调接口和回调函数是一码事。那么什么是回调函数呢？ </p>
<p>顾名思义，回调就是回过头去调用某个地方的函数，这种调用是注重时机的，在某个特定的时间回去调用特定的函数。假设一个场景，有一个button，点击button可以移除listview的第一个item(假设我们无法直接获取List数据集合)，这个时候就可以定义一个回调接口:</p>
<pre><code>public interface OnButtonClickListener
{
    void onClickRemove();
}
</code></pre><p>直接让Adapter实现这个接口</p>
<pre><code>@override 

public void onClickRemove()

{

    mItems.remove(0);

    notifyItemRemoved(0);

}
</code></pre><p>剩下的事情就很简单了，将adapter强转成接口，调用接口的方法，就可以实现数据集的删除操作。</p>
<p>以上就是一个回调的全过程：在button被点击的时机，我们在另一个环境（Adapter类）进行数据集的删除操作，并更新了view。</p>
<p>按照我的理解，当我们在开发过程中涉及到在两个环境间需要交互，比如一个Activity在特定时机需要知道所有Fragment的成员变量值，我们可以设计一个回调接口，让Fragment实现接口，将Fragment内的所有需要的参数打包到List集合，并作为返回值返回，我们直接在Activity获得这个回调接口的值便可以。也有一种带点逆向思维的方法，将实现放在Activity的匿名内部类以完成具体的业务逻辑（因为我们不需要对Fragment进行具体操），让Fragment调用接口，并将需要的参数传递过去。</p>
<p>总结：回调接口可以沟通两个不同的环境（或者说类）。假设一个类A和一个类B。接口的实现可以完成跨类的操作，接口的参数可以传递跨类操作时需要传递的参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在android开发中，回调接口出现的次数可谓不少，回调接口和回调函数是一码事。那么什么是回调函数呢？ &lt;/p&gt;
&lt;p&gt;顾名思义，回调就是回过头去调用某个地方的函数，这种调用是注重时机的，在某个特定的时间回去调用特定的函数。假设一个场景，有一个button，点击button
    
    </summary>
    
    
      <category term="随想" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
