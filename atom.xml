<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>居仙阁</title>
  <subtitle>有分享的地方就有成长的印记（本渣渣处于入门阶段，错误之处还望不吝指教）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-09T04:28:54.983Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xianhuojun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js学习小结</title>
    <link href="http://yoursite.com/2016/08/08/%E6%9D%82%E8%B0%88/"/>
    <id>http://yoursite.com/2016/08/08/杂谈/</id>
    <published>2016-08-08T13:07:50.000Z</published>
    <updated>2016-08-09T04:28:54.983Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先我们先来说说js中的this在不同情况下的指代，在我看来只有两种不同的用法。this都是在函数中，这两种说的是函数被使用的两种情况，一种是正常的被调用执行，另一种是作为构造函数被new出来。第一种，this指代的是调用这个方法的对象，比如，在script体中直接执行，this指代的就是window，在<code>function father(){var value=&quot;father&quot; }</code> new father().property = function test(){var value=”test” alert(this.value)};其中的this就是指代调用这个函数的对象father。还有一种比较特殊的调用情况，用call，apply将调用对象进行了转化，此时this指代的还是调用这个函数的对象，只是调用者被转换了而已。第二种，this指代函数本身，当一个函数作为构造函数生成对象是，该函数内的this就是指代函数对象本身。</p>
<p>　　然后我想说说jsp和Servlet的关系，请求jsp时，先检查在指定路径是否存在jsp。若存在并且是第一次访问，则将jsp转换成Servlet，并调用init初始化Servlet，这就生成了java文件，经过编译生成class字节码文件，最后执行返回结果，以后再次调用则直接从容器（服务器）调用Servlet，服务器被关闭的时候调用destory方法摧毁Servlet。总而言之，jsp生成Servlet，Servlet只会执行一次的init和destory，service则被多次调用。</p>
<p>　　那我们就扯到了jsp的内置对象了，jsp的内置对象有，request，response，session，application，page，pageContext，out，config，exception，转换成Servlet，我们有HttpServletRequest：实例为request，HttpServletResponse：实例为response，等等。这些内置对象作为已经实例好的对象，我们直接使用便可。这时候我们可以联想一下&lt;% %&gt;的工作流程了，在jsp中，我们预先生成java代码，在转化成Servlet的时候，&lt;%%&gt;内的内容不需要处理直接取出变可以了，所以，我们可以在这里面进行内置对象的各种使用，到时候会直接转换成Servlet的。</p>
<p>　　数组的定义方式：（1）声明：var array = new Array（）；赋值：array[0]=”1”;array[1]=”2”（2）声明与赋值： var array = new Array（”1”,”2”）；(3)声明与赋值：var array=[“1”,”2”];</p>
<p>　　局部变量，在函数体内用var声明的变量。全局变量，在函数体外和函数体内不加var声明的变量。</p>
<p>　　PrintWriter 是写到服务器上的。resp中的getWriter方法可以获得这个对象。接着用print方法就可以在页面上输出。Servlet的部署描述符web.xml肯定是要配置的，定位Servlet。servlet是嵌入了html代码的java类，jsp是嵌套了java代码的html页面</p>
<p>在新建一个项目之前， 让tomcat知道项目的路径：path用户访问的逻辑路径，docBase是实际物理地址。reloadable大多数类被修改后自动重启<br>　　<br>因为http是一个基于响应与请求的无状态协议，需要有一个session对象跟踪用户。当用户登陆成功的时候应该session.setAttribute();接着可以通过getAttribute()验证.原理与map有些相似，能保持多个会话。其实就是让用户一直保持跟服务器的连接，如果用户断开与服务器的连接了，Session很自然的需要消失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　首先我们先来说说js中的this在不同情况下的指代，在我看来只有两种不同的用法。this都是在函数中，这两种说的是函数被使用的两种情况，一种是正常的被调用执行，另一种是作为构造函数被new出来。第一种，this指代的是调用这个方法的对象，比如，在script体中直接执行
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>jsp中css,js文件引用路径小结</title>
    <link href="http://yoursite.com/2016/07/29/jsp%E4%B8%ADcss-js%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/29/jsp中css-js文件引用路径小结/</id>
    <published>2016-07-29T08:02:39.000Z</published>
    <updated>2016-07-29T09:05:57.026Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天下午花了不少时间找这方面的资料，自己总结一下。先讲自己已经理清头绪的：相对路径是指，相对当前的jsp页面来说的，也就是说假想当前目录就为此时的jsp页面，要走怎样的路径才可以到达目标js或者css。如果jsp文件与目标js或css在同一级目录，如图：</p>
<p><img src="https://raw.githubusercontent.com/wengxianhuo/pictures/master/same_dir.png" alt="同一目录"></p>
<pre><code>大家都知道，assets是存放js，css资源的文件即assets/js和assets/css，为了图片比较简洁，我就不展开assets目录了。
</code></pre><p>　　此时我们的相对路径应该这么写：assets/js/js文件 或者 assets/css/css文件。原因就是上面说的，对于相对路径，我们假想从当前jsp开始寻找目标资源，在同一级目录，是可以直接反问的，没什么弯路。</p>
<p>但是，还有另一种情况，即：</p>
<p><img src="https://raw.githubusercontent.com/wengxianhuo/pictures/master/other_dir.png" alt="同一目录"></p>
<p>　　在这种情况下我们当然是没办法像上面一样直接就寻得资源，如图可知道当前jsp在低一级的目录，这时候我们要先找到跑到assets目录才行啊，所以出现了..这样的格式，使用..可以让我们回到上一级目录，即assets的所在目录，都找到assets目录了，自然也可以直接寻得资源，写法是：../assets/js/js文件或../assets/css/css文件<br>    ..有一个特别之处，他会自动往上一级寻找，如果上一级没找到，会寻找上上一级，直到根目录都没有找到assets目录就直接not found了</p>
<p>　　现在我们推荐使用绝对路径就是/project/资源路径的形式，用这种方式出现的错误会比较少吧，感觉上。。。当然了，这里也有特别需要注意的一点就是，你在tomcat中的server配置中的context的path属性设置为什么，那对应的project就是什么。比如<code>&lt;Context path=&quot;/amazeUI&quot; docBase=&quot;AmazeUI&quot; reloadable=&quot;false&quot; /&gt;</code>那我设置的绝对路径就应该是/amazeUI/assert/js/js文件。</p>
<p>　　如有不正之处，请多多包涵，多多指教。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天下午花了不少时间找这方面的资料，自己总结一下。先讲自己已经理清头绪的：相对路径是指，相对当前的jsp页面来说的，也就是说假想当前目录就为此时的jsp页面，要走怎样的路径才可以到达目标js或者css。如果jsp文件与目标js或css在同一级目录，如图：&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="js，css引用路径" scheme="http://yoursite.com/tags/js%EF%BC%8Ccss%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈android回调</title>
    <link href="http://yoursite.com/2016/07/28/%E8%B0%88%E8%B0%88%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%99%E5%9B%9E%E4%BA%8B/"/>
    <id>http://yoursite.com/2016/07/28/谈谈回调函数这回事/</id>
    <published>2016-07-28T13:07:50.000Z</published>
    <updated>2016-07-29T09:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　在android开发中，回调接口出现的次数可谓不少，回调接口和回调函数是一码事。那么什么是回调函数呢？ </p>
<p>　　顾名思义，回调就是回过头去调用某个地方的函数，这种调用是注重时机的，在某个特定的时间回去调用特定的函数。假设一个场景，有一个button，点击button可以移除listview的第一个item，这个时候就可以定义一个回调接口:</p>
<p><code>public interface OnButtonClickListener{void onClickRemove();}</code></p>
<p>直接让Adapter实现这个接口</p>
<p>`@override </p>
<p>public void onClickRemove()</p>
<p>{</p>
<p>mItems.remove(0);</p>
<p>notifyItemRemoved(0);</p>
<p>}`</p>
<p>　　在button所在的MainActivity声明一个全局变量OnButtonClickListener mOnButtonClickListener = null；并且在给listview设置适配器的同时，将Adapter强转为OnButtonClickListener即</p>
<p><code>mOnButtonClickListener = (OnButtonClickListener)adapter;</code></p>
<p>这个时候我们就获得了回调接口的实现了。</p>
<p>　　万事俱备，就等时机到来。当button被点击的时候，我们就直接调用mOnButtonClickListener.onClickRemove()方法，实现了点击button删除第一个item的功能。</p>
<p>　　回过头来分析一下，回调的使用一般都是在两个环境中，在一个环境中的某个时机，我们想更新另一个环境的数据，那就考虑用回调了。接口实现方就是需要被更新的环境，接口调用方（也是接口书写的一方）通过调用接口的方法就可以去目标环境更新数据了。这就是回过去调用的过程嘛，当然，我们可以在调用方传递参数过去，以便实现特定功能，这就是看接口的书写格式咯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在android开发中，回调接口出现的次数可谓不少，回调接口和回调函数是一码事。那么什么是回调函数呢？ &lt;/p&gt;
&lt;p&gt;　　顾名思义，回调就是回过头去调用某个地方的函数，这种调用是注重时机的，在某个特定的时间回去调用特定的函数。假设一个场景，有一个button，点击bu
    
    </summary>
    
    
      <category term="随想" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
